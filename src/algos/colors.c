/*
 * This file is part of Siril, an astronomy image processor.
 * Copyright (C) 2005-2011 Francois Meyer (dulle at free.fr)
 * Copyright (C) 2012-2024 team free-astro (see more in AUTHORS file)
 * Reference site is https://siril.org
 *
 * Siril is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Siril is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Siril. If not, see <http://www.gnu.org/licenses/>.
 */

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <assert.h>
#include <float.h>

#include "core/siril.h"
#include "core/proto.h"
#include "core/icc_profile.h"
#include "core/processing.h"
#include "core/undo.h"
#include "core/siril_log.h"
#include "core/OS_utils.h"
#include "gui/progress_and_log.h"
#include "gui/histogram.h"
#include "io/single_image.h"
#include "io/image_format_fits.h"
#include "algos/colors.h"
#include "algos/statistics.h"
#include "algos/extraction.h"

/******************************************************************************
 * Note for maintainers: do not use the translation macro on the following    *
 * string. Color management relies on being able to detect "Extraction"       *
 * in FITS HISTORY header.                                                    *
 ******************************************************************************/
const gchar *extractionstring = "Extraction";

static gchar *add_filter_str[] = { "R", "G", "B"};
/*
 * A Fast HSL-to-RGB Transform
 * by Ken Fishkin
 * from "Graphics Gems", Academic Press, 1990
 * */
/*
 *  * given h,s,l on [0..1],
 *   * return r,g,b on [0..1]
 *    */
void hsl_to_rgb_float_sat(float h, float sl, float l, float * r, float * g,
		float * b) {
	float v;

	h = h >= 6.f ? h - 6.f : h;

	v = (l <= 0.5f) ? (l * (1.f + sl)) : (l + sl - l * sl);
	if (v <= 0.f) {
		*r = *g = *b = 0.f;
	} else {
		float m;
		float sv;
		int sextant;
		float fract, vsf, mid1, mid2;

		m = l + l - v;
		sv = (v - m) / v;
		sextant = h;
		fract = h - sextant;
		vsf = v * sv * fract;
		mid1 = m + vsf;
		mid2 = v - vsf;
		switch (sextant) {
			case 0:
				*r = v;
				*g = mid1;
				*b = m;
				break;
			case 1:
				*r = mid2;
				*g = v;
				*b = m;
				break;
			case 2:
				*r = m;
				*g = v;
				*b = mid1;
				break;
			case 3:
				*r = m;
				*g = mid2;
				*b = v;
				break;
			case 4:
				*r = mid1;
				*g = m;
				*b = v;
				break;
			case 5:
				*r = v;
				*g = m;
				*b = mid2;
				break;
		}
	}
}
/*
 *  * RGB-HSL transforms.
 *   * Ken Fishkin, Pixar Inc., January 1989.
 *    */

/*
 *  * given r,g,b on [0 ... 1],
 *   * return (h,s,l) on [0 ... 1]
 *    */
void rgb_to_hsl_float_sat(float r, float g, float b, float low, float *h, float *s, float *l) {
	float v;
	float m;
	float vm;
	float r2, g2, b2;

	v = max(r, g);
	v = max(v, b);
	m = min(r, g);
	m = min(m, b);

	if (m + v < low + low) {
		*l = 0.f;
		return;
	}
	*l = (m + v) / 2.f;
	*h = 0.f;
	*s = 0.f;	// init values

	if ((*s = vm = v - m) > 0.f) {
		*s /= (*l <= 0.5f) ? (v + m) : (2.f - v - m);
	} else
		return;

	if (r == v) {
		g2 = (v - g) / vm;
		b2 = (v - b) / vm;
		*h = (g == m ? 5.f + b2 : 1.f - g2);
	}else if (g == v) {
		r2 = (v - r) / vm;
		b2 = (v - b) / vm;
		*h = (b == m ? 1.f + r2 : 3.f - b2);
	} else {
		r2 = (v - r) / vm;
		g2 = (v - g) / vm;
		*h = (r == m ? 3.f + g2 : 5.f - r2);
	}

}

/*
 * A Fast HSL-to-RGB Transform
 * by Ken Fishkin
 * from "Graphics Gems", Academic Press, 1990
 * */
/*
 *  * given h,s,l on [0..1],
 *   * return r,g,b on [0..1]
 *    */
void hsl_to_rgb(double h, double sl, double l, double * r, double * g,
		double * b) {
	double v;

	assert(h >= 0.0 && h <= 1.0);
	if (h >= 1.0) h -= 1.0;		// this code doesn't work for h = 1
	v = (l <= 0.5) ? (l * (1.0 + sl)) : (l + sl - l * sl);
	if (v <= 0) {
		*r = *g = *b = 0.0;
	} else {
		double m;
		double sv;
		int sextant;
		double fract, vsf, mid1, mid2;

		m = l + l - v;
		sv = (v - m) / v;
		h *= 6.0;
		sextant = h;
		fract = h - sextant;
		vsf = v * sv * fract;
		mid1 = m + vsf;
		mid2 = v - vsf;
		switch (sextant) {
			case 0:
				*r = v;
				*g = mid1;
				*b = m;
				break;
			case 1:
				*r = mid2;
				*g = v;
				*b = m;
				break;
			case 2:
				*r = m;
				*g = v;
				*b = mid1;
				break;
			case 3:
				*r = m;
				*g = mid2;
				*b = v;
				break;
			case 4:
				*r = mid1;
				*g = m;
				*b = v;
				break;
			case 5:
				*r = v;
				*g = m;
				*b = mid2;
				break;
		}
	}
}

/* RGB-HSL transforms.
 * Ken Fishkin, Pixar Inc., January 1989.
 *
 * given r,g,b on [0 ... 1],
 * return (h,s,l) on [0 ... 1]
 */
void rgb_to_hsl(double r, double g, double b, double *h, double *s, double *l) {
	double v;
	double m;
	double vm;
	double r2, g2, b2;

	v = max(r, g);
	v = max(v, b);
	m = min(r, g);
	m = min(m, b);
	*h = 0.0;
	*s = 0.0;	// init values

	if ((*l = (m + v) / 2.0) <= 0.0) {
		*l = 0.0;
		return;
	}
	if ((*s = vm = v - m) > 0.0) {
		*s /= (*l <= 0.5) ? (v + m) : (2.0 - v - m);
	} else
		return;

	r2 = (v - r) / vm;
	g2 = (v - g) / vm;
	b2 = (v - b) / vm;

	if (r == v)
		*h = (g == m ? 5.0 + b2 : 1.0 - g2);
	else if (g == v)
		*h = (b == m ? 1.0 + r2 : 3.0 - b2);
	else
		*h = (r == m ? 3.0 + g2 : 5.0 - r2);

	*h /= 6;
}

// Single precision versions of the above
void hsl_to_rgbf(float h, float s, float l, float * r, float * g,
		float * b) {
	float v;

	assert(h >= 0.f && h <= 1.f);
	if (h >= 1.f) h -= 1.f;		// this code doesn't work for h = 1
	v = (l <= 0.5f) ? (l * (1.f + s)) : (l + s - l * s);
	if (v <= 0.f) {
		*r = *g = *b = 0.f;
	} else {
		float m;
		float sv;
		int sextant;
		float fract, vsf, mid1, mid2;

		m = l + l - v;
		sv = (v - m) / v;
		h *= 6.f;
		sextant = h;
		fract = h - sextant;
		vsf = v * sv * fract;
		mid1 = m + vsf;
		mid2 = v - vsf;
		switch (sextant) {
			case 0:
				*r = v;
				*g = mid1;
				*b = m;
				break;
			case 1:
				*r = mid2;
				*g = v;
				*b = m;
				break;
			case 2:
				*r = m;
				*g = v;
				*b = mid1;
				break;
			case 3:
				*r = m;
				*g = mid2;
				*b = v;
				break;
			case 4:
				*r = mid1;
				*g = m;
				*b = v;
				break;
			case 5:
				*r = v;
				*g = m;
				*b = mid2;
				break;
		}
	}
}

void rgb_to_hslf(float r, float g, float b, float *h, float *s, float *l) {
	float v;
	float m;
	float vm;
	float r2, g2, b2;

	v = max(r, g);
	v = max(v, b);
	m = min(r, g);
	m = min(m, b);
	*h = 0.f;
	*s = 0.f;	// init values

	if ((*l = (m + v) / 2.f) <= 0.f) {
		*l = 0.f;
		return;
	}
	if ((*s = vm = v - m) > 0.f) {
		*s /= (*l <= 0.5f) ? (v + m) : (2.f - v - m);
	} else
		return;

	r2 = (v - r) / vm;
	g2 = (v - g) / vm;
	b2 = (v - b) / vm;

	if (r == v)
		*h = (g == m ? 5.f + b2 : 1.f - g2);
	else if (g == v)
		*h = (b == m ? 1.f + r2 : 3.f - b2);
	else
		*h = (r == m ? 3.f + g2 : 5.f - r2);

	*h /= 6.f;
}

/* all variables are between 0 and 1. h takes 0 for grey */
void rgb_to_hsv(double r, double g, double b, double *h, double *s, double *v) {
	double cmax, cmin, delta;

	cmax = max(r, g);
	cmax = max(cmax, b);
	cmin = min(r, g);
	cmin = min(cmin, b);
	delta = cmax - cmin;
	*v = cmax;
	if (delta == 0.0) {
		*s = 0.0;
		*h = 0.0;
		return;
	}
	*s = delta / cmax;

	if (cmax == r)
		*h = (((g - b) / delta)) / 6.0;
	else if (cmax == g)
		*h = (((b - r) / delta) + 2.0) / 6.0;
	else
		*h = (((r - g) / delta) + 4.0) / 6.0;

	if (*h < 0.0)
		*h += 1.0;
}

void hsv_to_rgb(double h, double s, double v, double *r, double *g, double *b) {
	double p, q, t, f;
	int i;

	if (h >= 1.0)
		h -= 1.0;
	h *= 6.0;
	i = (int)h;
	f = h - (double)i;
	p = v * (1.0 - s);
	q = v * (1.0 - (s * f));
	t = v * (1.0 - (s * (1.0 - f)));

	switch (i) {
		case 0:
			*r = v;
			*g = t;
			*b = p;
			break;
		case 1:
			*r = q;
			*g = v;
			*b = p;
			break;
		case 2:
			*r = p;
			*g = v;
			*b = t;
			break;
		case 3:
			*r = p;
			*g = q;
			*b = v;
			break;
		case 4:
			*r = t;
			*g = p;
			*b = v;
			break;
		case 5:
		default:
			*r = v;
			*g = p;
			*b = q;
			break;
	}
}

void rgb_to_xyz(double r, double g, double b, double *x, double *y, double *z) {
	r = (r <= 0.04045) ? r / 12.92 : pow(((r + 0.055) / 1.055), 2.4);
	g = (g <= 0.04045) ? g / 12.92 : pow(((g + 0.055) / 1.055), 2.4);
	b = (b <= 0.04045) ? b / 12.92 : pow(((b + 0.055) / 1.055), 2.4);

	r *= 100;
	g *= 100;
	b *= 100;

	*x = 0.4124564 * r + 0.3575761 * g + 0.1804375 * b;
	*y = 0.2126729 * r + 0.7151522 * g + 0.0721750 * b;
	*z = 0.0193339 * r + 0.1191920 * g + 0.9503041 * b;
}

void rgb_to_xyzf(float r, float g, float b, float *x, float *y, float *z) {
	r = (r <= 0.04045f) ? r / 12.92f : powf(((r + 0.055f) / 1.055f), 2.4f);
	g = (g <= 0.04045f) ? g / 12.92f : powf(((g + 0.055f) / 1.055f), 2.4f);
	b = (b <= 0.04045f) ? b / 12.92f : powf(((b + 0.055f) / 1.055f), 2.4f);

	r *= 100.f;
	g *= 100.f;
	b *= 100.f;

	*x = 0.4124564f * r + 0.3575761f * g + 0.1804375f * b;
	*y = 0.2126729f * r + 0.7151522f * g + 0.0721750f * b;
	*z = 0.0193339f * r + 0.1191920f * g + 0.9503041f * b;
}

/* These functions have a scale argument as sometimes it is convenient to have
 * the Y channel output in the range [0..1] instead of [0..100]
 */

void linrgb_to_xyz(double r, double g, double b, double *x, double *y, double *z, gboolean scale) {
	if (scale) {
		r *= 100;
		g *= 100;
		b *= 100;
	}

	*x = 0.4124564 * r + 0.3575761 * g + 0.1804375 * b;
	*y = 0.2126729 * r + 0.7151522 * g + 0.0721750 * b;
	*z = 0.0193339 * r + 0.1191920 * g + 0.9503041 * b;
}

void linrgb_to_xyzf(float r, float g, float b, float *x, float *y, float *z, gboolean scale) {
	if (scale) {
		r *= 100.f;
		g *= 100.f;
		b *= 100.f;
	}

	*x = 0.4124564f * r + 0.3575761f * g + 0.1804375f * b;
	*y = 0.2126729f * r + 0.7151522f * g + 0.0721750f * b;
	*z = 0.0193339f * r + 0.1191920f * g + 0.9503041f * b;
}

void xyz_to_linrgb(double x, double y, double z, double *r, double *g, double *b, gboolean scale) {
	if (scale) {
		x /= 100.0;
		y /= 100.0;
		z /= 100.0;
	}

	*r =  3.2404542 * x - 1.5371385 * y - 0.4985314 * z;
	*g = -0.9692660 * x + 1.8760108 * y + 0.0415560 * z;
	*b =  0.0556434 * x - 0.2040259 * y + 1.0572252 * z;
}

void xyz_to_linrgbf(float x, float y, float z, float *r, float *g, float *b, gboolean scale) {
	if (scale) {
		x /= 100.f;
		y /= 100.f;
		z /= 100.f;
	}

	*r =  3.2404542f * x - 1.5371385f * y - 0.4985314f * z;
	*g = -0.9692660f * x + 1.8760108f * y + 0.0415560f * z;
	*b =  0.0556434f * x - 0.2040259f * y + 1.0572252f * z;
}

void rgb_to_yuvf(float red, float green, float blue, float *y, float *u, float *v) {
	const float a = 1.f / sqrtf(3.f);
	const float b = 1.f / sqrtf(2.f);
	const float c = 2.f * a * sqrtf(2.f);
	*y = a * (red + green + blue);
	*u = b * (red - blue);
	*v = c * (0.25f * red - 0.5f * green + 0.25f * blue);
}

void yuv_to_rgbf(float y, float u, float v, float *red, float *green, float *blue) {
	const float a = 1.f / sqrtf(3.f);
	const float b = 1.f / sqrtf(2.f);
	const float c = a / b;
	*red = (a * y) + (b * u) + (c * 0.5f * v);
	*green = (a * y) - (c * v);
	*blue = (a * y) - (b * u) + (c * 0.5f * v);
}


void xyz_to_LAB(double x, double y, double z, double *L, double *a, double *b) {
	x /= 95.047;
	y /= 100.000;
	z /= 108.883;

	x = (x > 0.008856452) ? pow(x, 1 / 3.0) : (7.787037037 * x) + (16. / 116.);
	y = (y > 0.008856452) ? pow(y, 1 / 3.0) : (7.787037037 * y) + (16. / 116.);
	z = (z > 0.008856452) ? pow(z, 1 / 3.0) : (7.787037037 * z) + (16. / 116.);

	*L = (116.0 * y) - 16.0;
	*a = 500.0 * (x - y);
	*b = 200.0 * (y - z);
}

void xyz_to_LABf(float x, float y, float z, float *L, float *a, float *b) {
	x /= 95.047f;
	y /= 100.000f;
	z /= 108.883f;

	x = (x > 0.008856452f) ? powf(x, 1.f / 3.0f) : (7.787037037f * x) + (16.f / 116.f);
	y = (y > 0.008856452f) ? powf(y, 1.f / 3.0f) : (7.787037037f * y) + (16.f / 116.f);
	z = (z > 0.008856452f) ? powf(z, 1.f / 3.0f) : (7.787037037f * z) + (16.f / 116.f);

	*L = (116.0f * y) - 16.0f;
	*a = 500.0f * (x - y);
	*b = 200.0f * (y - z);
}

void LAB_to_xyz(double L, double a, double b, double *x, double *y, double *z) {
	*y = (L + 16.0) / 116.0;
	*x = a / 500.0 + (*y);
	*z = *y - b / 200.0;

	double x3, y3, z3;
	x3 = (*x) * (*x) * (*x);
	y3 = (*y) * (*y) * (*y);
	z3 = (*z) * (*z) * (*z);

	*x = (x3 > 0.008856452) ? x3 : (*x - 16. / 116.) / 7.787037037;
	*y = (y3 > 0.008856452) ? y3 : (*y - 16. / 116.) / 7.787037037;
	*z = (z3 > 0.008856452) ? z3 : (*z - 16. / 116.) / 7.787037037;

	*x *= 95.047;
	*y *= 100.000;
	*z *= 108.883;
}

void LAB_to_xyzf(float L, float a, float b, float *x, float *y, float *z) {
	*y = (L + 16.0f) / 116.0f;
	*x = a / 500.0f + (*y);
	*z = *y - b / 200.0f;

	float x3, y3, z3;
	x3 = (*x) * (*x) * (*x);
	y3 = (*y) * (*y) * (*y);
	z3 = (*z) * (*z) * (*z);

	*x = (x3 > 0.008856452f) ? x3 : (*x - 16.f / 116.f) / 7.787037037f;
	*y = (y3 > 0.008856452f) ? y3 : (*y - 16.f / 116.f) / 7.787037037f;
	*z = (z3 > 0.008856452f) ? z3 : (*z - 16.f / 116.f) / 7.787037037f;

	*x *= 95.047f;
	*y *= 100.000f;
	*z *= 108.883f;
}

void xyz_to_rgb(double x, double y, double z, double *r, double *g, double *b) {
	x /= 100.0;
	y /= 100.0;
	z /= 100.0;

	*r =  3.2404542 * x - 1.5371385 * y - 0.4985314 * z;
	*g = -0.9692660 * x + 1.8760108 * y + 0.0415560 * z;
	*b =  0.0556434 * x - 0.2040259 * y + 1.0572252 * z;

	*r = (*r > 0.0031308) ? 1.055 * (pow(*r, (1 / 2.4))) - 0.055 : 12.92 * (*r);
	*g = (*g > 0.0031308) ? 1.055 * (pow(*g, (1 / 2.4))) - 0.055 : 12.92 * (*g);
	*b = (*b > 0.0031308) ? 1.055 * (pow(*b, (1 / 2.4))) - 0.055 : 12.92 * (*b);

}

void xyz_to_rgbf(float x, float y, float z, float *r, float *g, float *b) {
	x /= 100.0f;
	y /= 100.0f;
	z /= 100.0f;

	*r =  3.2404542f * x - 1.5371385f * y - 0.4985314f * z;
	*g = -0.9692660f * x + 1.8760108f * y + 0.0415560f * z;
	*b =  0.0556434f * x - 0.2040259f * y + 1.0572252f * z;

	*r = (*r > 0.0031308f) ? 1.055f * (powf(*r, (1.f / 2.4f))) - 0.055f : 12.92f * (*r);
	*g = (*g > 0.0031308f) ? 1.055f * (powf(*g, (1.f / 2.4f))) - 0.055f : 12.92f * (*g);
	*b = (*b > 0.0031308f) ? 1.055f * (powf(*b, (1.f / 2.4f))) - 0.055f : 12.92f * (*b);
}

// Reference: https://en.wikipedia.org/wiki/Color_index and https://arxiv.org/abs/1201.1809 (Ballesteros, F. J., 2012)
// Uses Ballesteros' formula based on considering stars as black bodies
double BV_to_T(double BV) {
	double T;

	// make sure BV is within its bounds [-0.4, 2] otherwise the math doesnt work
	if (BV < -0.4) {
		BV = -0.4;
	} else if (BV > 2) {
		BV = 2;
	}

	// http://www.wikiwand.com/en/Color_index
	T = 4600 * ((1 / ((0.92 * BV) + 1.7)) + (1 / ((0.92 * BV) + 0.62)));

	return T;
}

// CIE XYZ Color Matching Functions
// Ref: Wylie / Sloan / Shirley, Simple Analytic Approximations to the CIE XYZ
// Color Matching Functions, Journal of Computer Graphics Techniques, Vol. 2,
// No. 2, 2013.
/*static float cmf_g(float w, float mu, float t1, float t2) {
	float wmm = w - mu;
	return (w < mu) ?	expf(-t1 * t1 * wmm * wmm / 2.f) :
						expf(-t2 * t2 * wmm * wmm / 2.f);
}
*/
static float const xyz1931_1nm[471][3] = {
    { 0.000130f, 0.000004f, 0.000606f },    // 360 nm
    { 0.000146f, 0.000004f, 0.000681f },    // 361 nm
    { 0.000164f, 0.000005f, 0.000765f },    // 362 nm
    { 0.000184f, 0.000006f, 0.000860f },    // 363 nm
    { 0.000207f, 0.000006f, 0.000967f },    // 364 nm
    { 0.000232f, 0.000007f, 0.001086f },    // 365 nm
    { 0.000261f, 0.000008f, 0.001221f },    // 366 nm
    { 0.000293f, 0.000009f, 0.001373f },    // 367 nm
    { 0.000329f, 0.000010f, 0.001544f },    // 368 nm
    { 0.000370f, 0.000011f, 0.001734f },    // 369 nm
    { 0.000415f, 0.000012f, 0.001946f },    // 370 nm
    { 0.000464f, 0.000014f, 0.002178f },    // 371 nm
    { 0.000519f, 0.000016f, 0.002436f },    // 372 nm
    { 0.000582f, 0.000017f, 0.002732f },    // 373 nm
    { 0.000655f, 0.000020f, 0.003078f },    // 374 nm
    { 0.000742f, 0.000022f, 0.003486f },    // 375 nm
    { 0.000845f, 0.000025f, 0.003975f },    // 376 nm
    { 0.000965f, 0.000028f, 0.004541f },    // 377 nm
    { 0.001095f, 0.000032f, 0.005158f },    // 378 nm
    { 0.001231f, 0.000035f, 0.005803f },    // 379 nm
    { 0.001368f, 0.000039f, 0.006450f },    // 380 nm
    { 0.001502f, 0.000043f, 0.007083f },    // 381 nm
    { 0.001642f, 0.000047f, 0.007746f },    // 382 nm
    { 0.001802f, 0.000052f, 0.008501f },    // 383 nm
    { 0.001996f, 0.000057f, 0.009414f },    // 384 nm
    { 0.002236f, 0.000064f, 0.010550f },    // 385 nm
    { 0.002535f, 0.000072f, 0.011966f },    // 386 nm
    { 0.002893f, 0.000082f, 0.013656f },    // 387 nm
    { 0.003301f, 0.000094f, 0.015588f },    // 388 nm
    { 0.003753f, 0.000106f, 0.017730f },    // 389 nm
    { 0.004243f, 0.000120f, 0.020050f },    // 390 nm
    { 0.004762f, 0.000135f, 0.022511f },    // 391 nm
    { 0.005330f, 0.000152f, 0.025203f },    // 392 nm
    { 0.005979f, 0.000170f, 0.028280f },    // 393 nm
    { 0.006741f, 0.000192f, 0.031897f },    // 394 nm
    { 0.007650f, 0.000217f, 0.036210f },    // 395 nm
    { 0.008751f, 0.000247f, 0.041438f },    // 396 nm
    { 0.010029f, 0.000281f, 0.047504f },    // 397 nm
    { 0.011422f, 0.000319f, 0.054120f },    // 398 nm
    { 0.012869f, 0.000357f, 0.060998f },    // 399 nm
    { 0.014310f, 0.000396f, 0.067850f },    // 400 nm
    { 0.015704f, 0.000434f, 0.074486f },    // 401 nm
    { 0.017147f, 0.000473f, 0.081362f },    // 402 nm
    { 0.018781f, 0.000518f, 0.089154f },    // 403 nm
    { 0.020748f, 0.000572f, 0.098540f },    // 404 nm
    { 0.023190f, 0.000640f, 0.110200f },    // 405 nm
    { 0.026207f, 0.000725f, 0.124613f },    // 406 nm
    { 0.029783f, 0.000825f, 0.141702f },    // 407 nm
    { 0.033881f, 0.000941f, 0.161304f },    // 408 nm
    { 0.038468f, 0.001070f, 0.183257f },    // 409 nm
    { 0.043510f, 0.001210f, 0.207400f },    // 410 nm
    { 0.048996f, 0.001362f, 0.233692f },    // 411 nm
    { 0.055023f, 0.001531f, 0.262611f },    // 412 nm
    { 0.061719f, 0.001720f, 0.294775f },    // 413 nm
    { 0.069212f, 0.001935f, 0.330799f },    // 414 nm
    { 0.077630f, 0.002180f, 0.371300f },    // 415 nm
    { 0.086958f, 0.002455f, 0.416209f },    // 416 nm
    { 0.097177f, 0.002764f, 0.465464f },    // 417 nm
    { 0.108406f, 0.003118f, 0.519695f },    // 418 nm
    { 0.120767f, 0.003526f, 0.579530f },    // 419 nm
    { 0.134380f, 0.004000f, 0.645600f },    // 420 nm
    { 0.149358f, 0.004546f, 0.718484f },    // 421 nm
    { 0.165396f, 0.005159f, 0.796713f },    // 422 nm
    { 0.181983f, 0.005829f, 0.877846f },    // 423 nm
    { 0.198611f, 0.006546f, 0.959439f },    // 424 nm
    { 0.214770f, 0.007300f, 1.039050f },    // 425 nm
    { 0.230187f, 0.008086f, 1.115367f },    // 426 nm
    { 0.244880f, 0.008909f, 1.188497f },    // 427 nm
    { 0.258777f, 0.009768f, 1.258123f },    // 428 nm
    { 0.271808f, 0.010664f, 1.323930f },    // 429 nm
    { 0.283900f, 0.011600f, 1.385600f },    // 430 nm
    { 0.294944f, 0.012573f, 1.442635f },    // 431 nm
    { 0.304897f, 0.013583f, 1.494804f },    // 432 nm
    { 0.313787f, 0.014630f, 1.542190f },    // 433 nm
    { 0.321645f, 0.015715f, 1.584881f },    // 434 nm
    { 0.328500f, 0.016840f, 1.622960f },    // 435 nm
    { 0.334351f, 0.018007f, 1.656405f },    // 436 nm
    { 0.339210f, 0.019214f, 1.685296f },    // 437 nm
    { 0.343121f, 0.020454f, 1.709875f },    // 438 nm
    { 0.346130f, 0.021718f, 1.730382f },    // 439 nm
    { 0.348280f, 0.023000f, 1.747060f },    // 440 nm
    { 0.349600f, 0.024295f, 1.760045f },    // 441 nm
    { 0.350147f, 0.025610f, 1.769623f },    // 442 nm
    { 0.350013f, 0.026959f, 1.776264f },    // 443 nm
    { 0.349287f, 0.028351f, 1.780433f },    // 444 nm
    { 0.348060f, 0.029800f, 1.782600f },    // 445 nm
    { 0.346373f, 0.031311f, 1.782968f },    // 446 nm
    { 0.344262f, 0.032884f, 1.781700f },    // 447 nm
    { 0.341809f, 0.034521f, 1.779198f },    // 448 nm
    { 0.339094f, 0.036226f, 1.775867f },    // 449 nm
    { 0.336200f, 0.038000f, 1.772110f },    // 450 nm
    { 0.333198f, 0.039847f, 1.768259f },    // 451 nm
    { 0.330041f, 0.041768f, 1.764039f },    // 452 nm
    { 0.326636f, 0.043766f, 1.758944f },    // 453 nm
    { 0.322887f, 0.045843f, 1.752466f },    // 454 nm
    { 0.318700f, 0.048000f, 1.744100f },    // 455 nm
    { 0.314025f, 0.050244f, 1.733559f },    // 456 nm
    { 0.308884f, 0.052573f, 1.720858f },    // 457 nm
    { 0.303290f, 0.054981f, 1.705937f },    // 458 nm
    { 0.297258f, 0.057459f, 1.688737f },    // 459 nm
    { 0.290800f, 0.060000f, 1.669200f },    // 460 nm
    { 0.283970f, 0.062602f, 1.647529f },    // 461 nm
    { 0.276721f, 0.065278f, 1.623413f },    // 462 nm
    { 0.268918f, 0.068042f, 1.596022f },    // 463 nm
    { 0.260423f, 0.070911f, 1.564528f },    // 464 nm
    { 0.251100f, 0.073900f, 1.528100f },    // 465 nm
    { 0.240847f, 0.077016f, 1.486111f },    // 466 nm
    { 0.229851f, 0.080266f, 1.439522f },    // 467 nm
    { 0.218407f, 0.083667f, 1.389880f },    // 468 nm
    { 0.206812f, 0.087233f, 1.338736f },    // 469 nm
    { 0.195360f, 0.090980f, 1.287640f },    // 470 nm
    { 0.184214f, 0.094918f, 1.237422f },    // 471 nm
    { 0.173327f, 0.099046f, 1.187824f },    // 472 nm
    { 0.162688f, 0.103367f, 1.138761f },    // 473 nm
    { 0.152283f, 0.107885f, 1.090148f },    // 474 nm
    { 0.142100f, 0.112600f, 1.041900f },    // 475 nm
    { 0.132179f, 0.117532f, 0.994198f },    // 476 nm
    { 0.122570f, 0.122674f, 0.947347f },    // 477 nm
    { 0.113275f, 0.127993f, 0.901453f },    // 478 nm
    { 0.104298f, 0.133453f, 0.856619f },    // 479 nm
    { 0.095640f, 0.139020f, 0.812950f },    // 480 nm
    { 0.087300f, 0.144676f, 0.770517f },    // 481 nm
    { 0.079308f, 0.150469f, 0.729445f },    // 482 nm
    { 0.071718f, 0.156462f, 0.689914f },    // 483 nm
    { 0.064581f, 0.162718f, 0.652105f },    // 484 nm
    { 0.057950f, 0.169300f, 0.616200f },    // 485 nm
    { 0.051862f, 0.176243f, 0.582329f },    // 486 nm
    { 0.046282f, 0.183558f, 0.550416f },    // 487 nm
    { 0.041151f, 0.191273f, 0.520338f },    // 488 nm
    { 0.036413f, 0.199418f, 0.491967f },    // 489 nm
    { 0.032010f, 0.208020f, 0.465180f },    // 490 nm
    { 0.027917f, 0.217120f, 0.439925f },    // 491 nm
    { 0.024144f, 0.226735f, 0.416184f },    // 492 nm
    { 0.020687f, 0.236857f, 0.393882f },    // 493 nm
    { 0.017540f, 0.247481f, 0.372946f },    // 494 nm
    { 0.014700f, 0.258600f, 0.353300f },    // 495 nm
    { 0.012162f, 0.270185f, 0.334858f },    // 496 nm
    { 0.009920f, 0.282294f, 0.317552f },    // 497 nm
    { 0.007967f, 0.295051f, 0.301338f },    // 498 nm
    { 0.006296f, 0.308578f, 0.286169f },    // 499 nm
    { 0.004900f, 0.323000f, 0.272000f },    // 500 nm
    { 0.003777f, 0.338402f, 0.258817f },    // 501 nm
    { 0.002945f, 0.354686f, 0.246484f },    // 502 nm
    { 0.002425f, 0.371699f, 0.234772f },    // 503 nm
    { 0.002236f, 0.389288f, 0.223453f },    // 504 nm
    { 0.002400f, 0.407300f, 0.212300f },    // 505 nm
    { 0.002926f, 0.425630f, 0.201169f },    // 506 nm
    { 0.003837f, 0.444310f, 0.190120f },    // 507 nm
    { 0.005175f, 0.463394f, 0.179225f },    // 508 nm
    { 0.006982f, 0.482940f, 0.168561f },    // 509 nm
    { 0.009300f, 0.503000f, 0.158200f },    // 510 nm
    { 0.012149f, 0.523569f, 0.148138f },    // 511 nm
    { 0.015536f, 0.544512f, 0.138376f },    // 512 nm
    { 0.019477f, 0.565690f, 0.128994f },    // 513 nm
    { 0.023993f, 0.586965f, 0.120075f },    // 514 nm
    { 0.029100f, 0.608200f, 0.111700f },    // 515 nm
    { 0.034815f, 0.629346f, 0.103905f },    // 516 nm
    { 0.041120f, 0.650307f, 0.096667f },    // 517 nm
    { 0.047985f, 0.670875f, 0.089983f },    // 518 nm
    { 0.055379f, 0.690842f, 0.083845f },    // 519 nm
    { 0.063270f, 0.710000f, 0.078250f },    // 520 nm
    { 0.071635f, 0.728185f, 0.073209f },    // 521 nm
    { 0.080462f, 0.745464f, 0.068678f },    // 522 nm
    { 0.089740f, 0.761969f, 0.064568f },    // 523 nm
    { 0.099456f, 0.777837f, 0.060788f },    // 524 nm
    { 0.109600f, 0.793200f, 0.057250f },    // 525 nm
    { 0.120167f, 0.808110f, 0.053904f },    // 526 nm
    { 0.131114f, 0.822496f, 0.050747f },    // 527 nm
    { 0.142368f, 0.836307f, 0.047753f },    // 528 nm
    { 0.153854f, 0.849492f, 0.044899f },    // 529 nm
    { 0.165500f, 0.862000f, 0.042160f },    // 530 nm
    { 0.177257f, 0.873811f, 0.039507f },    // 531 nm
    { 0.189140f, 0.884962f, 0.036936f },    // 532 nm
    { 0.201169f, 0.895494f, 0.034458f },    // 533 nm
    { 0.213366f, 0.905443f, 0.032089f },    // 534 nm
    { 0.225750f, 0.914850f, 0.029840f },    // 535 nm
    { 0.238321f, 0.923735f, 0.027712f },    // 536 nm
    { 0.251067f, 0.932092f, 0.025694f },    // 537 nm
    { 0.263992f, 0.939923f, 0.023787f },    // 538 nm
    { 0.277102f, 0.947225f, 0.021989f },    // 539 nm
    { 0.290400f, 0.954000f, 0.020300f },    // 540 nm
    { 0.303891f, 0.960256f, 0.018718f },    // 541 nm
    { 0.317573f, 0.966007f, 0.017240f },    // 542 nm
    { 0.331438f, 0.971261f, 0.015864f },    // 543 nm
    { 0.345483f, 0.976022f, 0.014585f },    // 544 nm
    { 0.359700f, 0.980300f, 0.013400f },    // 545 nm
    { 0.374084f, 0.984092f, 0.012307f },    // 546 nm
    { 0.388640f, 0.987418f, 0.011302f },    // 547 nm
    { 0.403378f, 0.990313f, 0.010378f },    // 548 nm
    { 0.418312f, 0.992812f, 0.009529f },    // 549 nm
    { 0.433450f, 0.994950f, 0.008750f },    // 550 nm
    { 0.448795f, 0.996711f, 0.008035f },    // 551 nm
    { 0.464336f, 0.998098f, 0.007382f },    // 552 nm
    { 0.480064f, 0.999112f, 0.006785f },    // 553 nm
    { 0.495971f, 0.999748f, 0.006243f },    // 554 nm
    { 0.512050f, 1.000000f, 0.005750f },    // 555 nm
    { 0.528296f, 0.999857f, 0.005304f },    // 556 nm
    { 0.544692f, 0.999305f, 0.004900f },    // 557 nm
    { 0.561209f, 0.998326f, 0.004534f },    // 558 nm
    { 0.577821f, 0.996899f, 0.004202f },    // 559 nm
    { 0.594500f, 0.995000f, 0.003900f },    // 560 nm
    { 0.611221f, 0.992601f, 0.003623f },    // 561 nm
    { 0.627976f, 0.989743f, 0.003371f },    // 562 nm
    { 0.644760f, 0.986444f, 0.003141f },    // 563 nm
    { 0.661570f, 0.982724f, 0.002935f },    // 564 nm
    { 0.678400f, 0.978600f, 0.002750f },    // 565 nm
    { 0.695239f, 0.974084f, 0.002585f },    // 566 nm
    { 0.712059f, 0.969171f, 0.002439f },    // 567 nm
    { 0.728828f, 0.963857f, 0.002309f },    // 568 nm
    { 0.745519f, 0.958135f, 0.002197f },    // 569 nm
    { 0.762100f, 0.952000f, 0.002100f },    // 570 nm
    { 0.778543f, 0.945450f, 0.002018f },    // 571 nm
    { 0.794826f, 0.938499f, 0.001948f },    // 572 nm
    { 0.810926f, 0.931163f, 0.001890f },    // 573 nm
    { 0.826825f, 0.923458f, 0.001841f },    // 574 nm
    { 0.842500f, 0.915400f, 0.001800f },    // 575 nm
    { 0.857933f, 0.907006f, 0.001766f },    // 576 nm
    { 0.873082f, 0.898277f, 0.001738f },    // 577 nm
    { 0.887894f, 0.889205f, 0.001711f },    // 578 nm
    { 0.902318f, 0.879782f, 0.001683f },    // 579 nm
    { 0.916300f, 0.870000f, 0.001650f },    // 580 nm
    { 0.929799f, 0.859861f, 0.001610f },    // 581 nm
    { 0.942798f, 0.849392f, 0.001564f },    // 582 nm
    { 0.955278f, 0.838622f, 0.001514f },    // 583 nm
    { 0.967218f, 0.827581f, 0.001459f },    // 584 nm
    { 0.978600f, 0.816300f, 0.001400f },    // 585 nm
    { 0.989386f, 0.804795f, 0.001337f },    // 586 nm
    { 0.999549f, 0.793082f, 0.001270f },    // 587 nm
    { 1.009089f, 0.781192f, 0.001205f },    // 588 nm
    { 1.018006f, 0.769155f, 0.001147f },    // 589 nm
    { 1.026300f, 0.757000f, 0.001100f },    // 590 nm
    { 1.033983f, 0.744754f, 0.001069f },    // 591 nm
    { 1.040986f, 0.732422f, 0.001049f },    // 592 nm
    { 1.047188f, 0.720004f, 0.001036f },    // 593 nm
    { 1.052467f, 0.707497f, 0.001021f },    // 594 nm
    { 1.056700f, 0.694900f, 0.001000f },    // 595 nm
    { 1.059794f, 0.682219f, 0.000969f },    // 596 nm
    { 1.061799f, 0.669472f, 0.000930f },    // 597 nm
    { 1.062807f, 0.656674f, 0.000887f },    // 598 nm
    { 1.062910f, 0.643845f, 0.000843f },    // 599 nm
    { 1.062200f, 0.631000f, 0.000800f },    // 600 nm
    { 1.060735f, 0.618155f, 0.000761f },    // 601 nm
    { 1.058444f, 0.605314f, 0.000724f },    // 602 nm
    { 1.055224f, 0.592476f, 0.000686f },    // 603 nm
    { 1.050977f, 0.579638f, 0.000645f },    // 604 nm
    { 1.045600f, 0.566800f, 0.000600f },    // 605 nm
    { 1.039037f, 0.553961f, 0.000548f },    // 606 nm
    { 1.031361f, 0.541137f, 0.000492f },    // 607 nm
    { 1.022666f, 0.528353f, 0.000435f },    // 608 nm
    { 1.013048f, 0.515632f, 0.000384f },    // 609 nm
    { 1.002600f, 0.503000f, 0.000340f },    // 610 nm
    { 0.991368f, 0.490469f, 0.000307f },    // 611 nm
    { 0.979331f, 0.478030f, 0.000283f },    // 612 nm
    { 0.966492f, 0.465678f, 0.000265f },    // 613 nm
    { 0.952848f, 0.453403f, 0.000252f },    // 614 nm
    { 0.938400f, 0.441200f, 0.000240f },    // 615 nm
    { 0.923194f, 0.429080f, 0.000230f },    // 616 nm
    { 0.907244f, 0.417036f, 0.000221f },    // 617 nm
    { 0.890502f, 0.405032f, 0.000212f },    // 618 nm
    { 0.872920f, 0.393032f, 0.000202f },    // 619 nm
    { 0.854450f, 0.381000f, 0.000190f },    // 620 nm
    { 0.835084f, 0.368918f, 0.000174f },    // 621 nm
    { 0.814946f, 0.356827f, 0.000156f },    // 622 nm
    { 0.794186f, 0.344777f, 0.000136f },    // 623 nm
    { 0.772954f, 0.332818f, 0.000117f },    // 624 nm
    { 0.751400f, 0.321000f, 0.000100f },    // 625 nm
    { 0.729584f, 0.309338f, 0.000086f },    // 626 nm
    { 0.707589f, 0.297850f, 0.000075f },    // 627 nm
    { 0.685602f, 0.286594f, 0.000065f },    // 628 nm
    { 0.663810f, 0.275625f, 0.000057f },    // 629 nm
    { 0.642400f, 0.265000f, 0.000050f },    // 630 nm
    { 0.621515f, 0.254763f, 0.000044f },    // 631 nm
    { 0.601114f, 0.244890f, 0.000039f },    // 632 nm
    { 0.581105f, 0.235334f, 0.000036f },    // 633 nm
    { 0.561398f, 0.226053f, 0.000033f },    // 634 nm
    { 0.541900f, 0.217000f, 0.000030f },    // 635 nm
    { 0.522600f, 0.208162f, 0.000028f },    // 636 nm
    { 0.503546f, 0.199549f, 0.000026f },    // 637 nm
    { 0.484744f, 0.191155f, 0.000024f },    // 638 nm
    { 0.466194f, 0.182974f, 0.000022f },    // 639 nm
    { 0.447900f, 0.175000f, 0.000020f },    // 640 nm
    { 0.429861f, 0.167223f, 0.000018f },    // 641 nm
    { 0.412098f, 0.159646f, 0.000016f },    // 642 nm
    { 0.394644f, 0.152278f, 0.000014f },    // 643 nm
    { 0.377533f, 0.145126f, 0.000012f },    // 644 nm
    { 0.360800f, 0.138200f, 0.000010f },    // 645 nm
    { 0.344456f, 0.131500f, 0.000008f },    // 646 nm
    { 0.328517f, 0.125025f, 0.000005f },    // 647 nm
    { 0.313019f, 0.118779f, 0.000003f },    // 648 nm
    { 0.298001f, 0.112769f, 0.000001f },    // 649 nm
    { 0.283500f, 0.107000f, 0.000000f },    // 650 nm
    { 0.269545f, 0.101476f, 0.000000f },    // 651 nm
    { 0.256118f, 0.096189f, 0.000000f },    // 652 nm
    { 0.243190f, 0.091123f, 0.000000f },    // 653 nm
    { 0.230727f, 0.086265f, 0.000000f },    // 654 nm
    { 0.218700f, 0.081600f, 0.000000f },    // 655 nm
    { 0.207097f, 0.077121f, 0.000000f },    // 656 nm
    { 0.195923f, 0.072825f, 0.000000f },    // 657 nm
    { 0.185171f, 0.068710f, 0.000000f },    // 658 nm
    { 0.174832f, 0.064770f, 0.000000f },    // 659 nm
    { 0.164900f, 0.061000f, 0.000000f },    // 660 nm
    { 0.155367f, 0.057396f, 0.000000f },    // 661 nm
    { 0.146230f, 0.053955f, 0.000000f },    // 662 nm
    { 0.137490f, 0.050674f, 0.000000f },    // 663 nm
    { 0.129147f, 0.047550f, 0.000000f },    // 664 nm
    { 0.121200f, 0.044580f, 0.000000f },    // 665 nm
    { 0.113640f, 0.041759f, 0.000000f },    // 666 nm
    { 0.106465f, 0.039085f, 0.000000f },    // 667 nm
    { 0.099690f, 0.036564f, 0.000000f },    // 668 nm
    { 0.093331f, 0.034201f, 0.000000f },    // 669 nm
    { 0.087400f, 0.032000f, 0.000000f },    // 670 nm
    { 0.081901f, 0.029963f, 0.000000f },    // 671 nm
    { 0.076804f, 0.028077f, 0.000000f },    // 672 nm
    { 0.072077f, 0.026329f, 0.000000f },    // 673 nm
    { 0.067687f, 0.024708f, 0.000000f },    // 674 nm
    { 0.063600f, 0.023200f, 0.000000f },    // 675 nm
    { 0.059807f, 0.021801f, 0.000000f },    // 676 nm
    { 0.056282f, 0.020501f, 0.000000f },    // 677 nm
    { 0.052971f, 0.019281f, 0.000000f },    // 678 nm
    { 0.049819f, 0.018121f, 0.000000f },    // 679 nm
    { 0.046770f, 0.017000f, 0.000000f },    // 680 nm
    { 0.043784f, 0.015904f, 0.000000f },    // 681 nm
    { 0.040875f, 0.014837f, 0.000000f },    // 682 nm
    { 0.038073f, 0.013811f, 0.000000f },    // 683 nm
    { 0.035405f, 0.012835f, 0.000000f },    // 684 nm
    { 0.032900f, 0.011920f, 0.000000f },    // 685 nm
    { 0.030564f, 0.011068f, 0.000000f },    // 686 nm
    { 0.028381f, 0.010273f, 0.000000f },    // 687 nm
    { 0.026345f, 0.009533f, 0.000000f },    // 688 nm
    { 0.024453f, 0.008846f, 0.000000f },    // 689 nm
    { 0.022700f, 0.008210f, 0.000000f },    // 690 nm
    { 0.021084f, 0.007624f, 0.000000f },    // 691 nm
    { 0.019600f, 0.007085f, 0.000000f },    // 692 nm
    { 0.018237f, 0.006591f, 0.000000f },    // 693 nm
    { 0.016987f, 0.006138f, 0.000000f },    // 694 nm
    { 0.015840f, 0.005723f, 0.000000f },    // 695 nm
    { 0.014791f, 0.005343f, 0.000000f },    // 696 nm
    { 0.013831f, 0.004996f, 0.000000f },    // 697 nm
    { 0.012949f, 0.004676f, 0.000000f },    // 698 nm
    { 0.012129f, 0.004380f, 0.000000f },    // 699 nm
    { 0.011359f, 0.004102f, 0.000000f },    // 700 nm
    { 0.010629f, 0.003839f, 0.000000f },    // 701 nm
    { 0.009939f, 0.003589f, 0.000000f },    // 702 nm
    { 0.009288f, 0.003354f, 0.000000f },    // 703 nm
    { 0.008679f, 0.003134f, 0.000000f },    // 704 nm
    { 0.008111f, 0.002929f, 0.000000f },    // 705 nm
    { 0.007582f, 0.002738f, 0.000000f },    // 706 nm
    { 0.007089f, 0.002560f, 0.000000f },    // 707 nm
    { 0.006627f, 0.002393f, 0.000000f },    // 708 nm
    { 0.006195f, 0.002237f, 0.000000f },    // 709 nm
    { 0.005790f, 0.002091f, 0.000000f },    // 710 nm
    { 0.005410f, 0.001954f, 0.000000f },    // 711 nm
    { 0.005053f, 0.001825f, 0.000000f },    // 712 nm
    { 0.004717f, 0.001704f, 0.000000f },    // 713 nm
    { 0.004403f, 0.001590f, 0.000000f },    // 714 nm
    { 0.004109f, 0.001484f, 0.000000f },    // 715 nm
    { 0.003834f, 0.001384f, 0.000000f },    // 716 nm
    { 0.003576f, 0.001291f, 0.000000f },    // 717 nm
    { 0.003334f, 0.001204f, 0.000000f },    // 718 nm
    { 0.003109f, 0.001123f, 0.000000f },    // 719 nm
    { 0.002899f, 0.001047f, 0.000000f },    // 720 nm
    { 0.002704f, 0.000977f, 0.000000f },    // 721 nm
    { 0.002523f, 0.000911f, 0.000000f },    // 722 nm
    { 0.002354f, 0.000850f, 0.000000f },    // 723 nm
    { 0.002197f, 0.000793f, 0.000000f },    // 724 nm
    { 0.002049f, 0.000740f, 0.000000f },    // 725 nm
    { 0.001911f, 0.000690f, 0.000000f },    // 726 nm
    { 0.001781f, 0.000643f, 0.000000f },    // 727 nm
    { 0.001660f, 0.000600f, 0.000000f },    // 728 nm
    { 0.001547f, 0.000559f, 0.000000f },    // 729 nm
    { 0.001440f, 0.000520f, 0.000000f },    // 730 nm
    { 0.001340f, 0.000484f, 0.000000f },    // 731 nm
    { 0.001246f, 0.000450f, 0.000000f },    // 732 nm
    { 0.001158f, 0.000418f, 0.000000f },    // 733 nm
    { 0.001076f, 0.000389f, 0.000000f },    // 734 nm
    { 0.001000f, 0.000361f, 0.000000f },    // 735 nm
    { 0.000929f, 0.000335f, 0.000000f },    // 736 nm
    { 0.000862f, 0.000311f, 0.000000f },    // 737 nm
    { 0.000801f, 0.000289f, 0.000000f },    // 738 nm
    { 0.000743f, 0.000269f, 0.000000f },    // 739 nm
    { 0.000690f, 0.000249f, 0.000000f },    // 740 nm
    { 0.000640f, 0.000231f, 0.000000f },    // 741 nm
    { 0.000594f, 0.000215f, 0.000000f },    // 742 nm
    { 0.000552f, 0.000199f, 0.000000f },    // 743 nm
    { 0.000512f, 0.000185f, 0.000000f },    // 744 nm
    { 0.000476f, 0.000172f, 0.000000f },    // 745 nm
    { 0.000442f, 0.000160f, 0.000000f },    // 746 nm
    { 0.000411f, 0.000149f, 0.000000f },    // 747 nm
    { 0.000383f, 0.000138f, 0.000000f },    // 748 nm
    { 0.000357f, 0.000129f, 0.000000f },    // 749 nm
    { 0.000332f, 0.000120f, 0.000000f },    // 750 nm
    { 0.000310f, 0.000112f, 0.000000f },    // 751 nm
    { 0.000289f, 0.000104f, 0.000000f },    // 752 nm
    { 0.000269f, 0.000097f, 0.000000f },    // 753 nm
    { 0.000252f, 0.000091f, 0.000000f },    // 754 nm
    { 0.000235f, 0.000085f, 0.000000f },    // 755 nm
    { 0.000219f, 0.000079f, 0.000000f },    // 756 nm
    { 0.000205f, 0.000074f, 0.000000f },    // 757 nm
    { 0.000191f, 0.000069f, 0.000000f },    // 758 nm
    { 0.000178f, 0.000064f, 0.000000f },    // 759 nm
    { 0.000166f, 0.000060f, 0.000000f },    // 760 nm
    { 0.000155f, 0.000056f, 0.000000f },    // 761 nm
    { 0.000145f, 0.000052f, 0.000000f },    // 762 nm
    { 0.000135f, 0.000049f, 0.000000f },    // 763 nm
    { 0.000126f, 0.000045f, 0.000000f },    // 764 nm
    { 0.000117f, 0.000042f, 0.000000f },    // 765 nm
    { 0.000110f, 0.000040f, 0.000000f },    // 766 nm
    { 0.000102f, 0.000037f, 0.000000f },    // 767 nm
    { 0.000095f, 0.000034f, 0.000000f },    // 768 nm
    { 0.000089f, 0.000032f, 0.000000f },    // 769 nm
    { 0.000083f, 0.000030f, 0.000000f },    // 770 nm
    { 0.000078f, 0.000028f, 0.000000f },    // 771 nm
    { 0.000072f, 0.000026f, 0.000000f },    // 772 nm
    { 0.000067f, 0.000024f, 0.000000f },    // 773 nm
    { 0.000063f, 0.000023f, 0.000000f },    // 774 nm
    { 0.000059f, 0.000021f, 0.000000f },    // 775 nm
    { 0.000055f, 0.000020f, 0.000000f },    // 776 nm
    { 0.000051f, 0.000018f, 0.000000f },    // 777 nm
    { 0.000048f, 0.000017f, 0.000000f },    // 778 nm
    { 0.000044f, 0.000016f, 0.000000f },    // 779 nm
    { 0.000042f, 0.000015f, 0.000000f },    // 780 nm
    { 0.000039f, 0.000014f, 0.000000f },    // 781 nm
    { 0.000036f, 0.000013f, 0.000000f },    // 782 nm
    { 0.000034f, 0.000012f, 0.000000f },    // 783 nm
    { 0.000031f, 0.000011f, 0.000000f },    // 784 nm
    { 0.000029f, 0.000011f, 0.000000f },    // 785 nm
    { 0.000027f, 0.000010f, 0.000000f },    // 786 nm
    { 0.000026f, 0.000009f, 0.000000f },    // 787 nm
    { 0.000024f, 0.000009f, 0.000000f },    // 788 nm
    { 0.000022f, 0.000008f, 0.000000f },    // 789 nm
    { 0.000021f, 0.000007f, 0.000000f },    // 790 nm
    { 0.000019f, 0.000007f, 0.000000f },    // 791 nm
    { 0.000018f, 0.000006f, 0.000000f },    // 792 nm
    { 0.000017f, 0.000006f, 0.000000f },    // 793 nm
    { 0.000016f, 0.000006f, 0.000000f },    // 794 nm
    { 0.000015f, 0.000005f, 0.000000f },    // 795 nm
    { 0.000014f, 0.000005f, 0.000000f },    // 796 nm
    { 0.000013f, 0.000005f, 0.000000f },    // 797 nm
    { 0.000012f, 0.000004f, 0.000000f },    // 798 nm
    { 0.000011f, 0.000004f, 0.000000f },    // 799 nm
    { 0.000010f, 0.000004f, 0.000000f },    // 800 nm
    { 0.000010f, 0.000003f, 0.000000f },    // 801 nm
    { 0.000009f, 0.000003f, 0.000000f },    // 802 nm
    { 0.000008f, 0.000003f, 0.000000f },    // 803 nm
    { 0.000008f, 0.000003f, 0.000000f },    // 804 nm
    { 0.000007f, 0.000003f, 0.000000f },    // 805 nm
    { 0.000007f, 0.000002f, 0.000000f },    // 806 nm
    { 0.000006f, 0.000002f, 0.000000f },    // 807 nm
    { 0.000006f, 0.000002f, 0.000000f },    // 808 nm
    { 0.000005f, 0.000002f, 0.000000f },    // 809 nm
    { 0.000005f, 0.000002f, 0.000000f },    // 810 nm
    { 0.000005f, 0.000002f, 0.000000f },    // 811 nm
    { 0.000004f, 0.000002f, 0.000000f },    // 812 nm
    { 0.000004f, 0.000001f, 0.000000f },    // 813 nm
    { 0.000004f, 0.000001f, 0.000000f },    // 814 nm
    { 0.000004f, 0.000001f, 0.000000f },    // 815 nm
    { 0.000003f, 0.000001f, 0.000000f },    // 816 nm
    { 0.000003f, 0.000001f, 0.000000f },    // 817 nm
    { 0.000003f, 0.000001f, 0.000000f },    // 818 nm
    { 0.000003f, 0.000001f, 0.000000f },    // 819 nm
    { 0.000003f, 0.000001f, 0.000000f },    // 820 nm
    { 0.000002f, 0.000001f, 0.000000f },    // 821 nm
    { 0.000002f, 0.000001f, 0.000000f },    // 822 nm
    { 0.000002f, 0.000001f, 0.000000f },    // 823 nm
    { 0.000002f, 0.000001f, 0.000000f },    // 824 nm
    { 0.000002f, 0.000001f, 0.000000f },    // 825 nm
    { 0.000002f, 0.000001f, 0.000000f },    // 826 nm
    { 0.000002f, 0.000001f, 0.000000f },    // 827 nm
    { 0.000001f, 0.000001f, 0.000000f },    // 828 nm
    { 0.000001f, 0.000000f, 0.000000f },    // 829 nm
    { 0.000001f, 0.000000f, 0.000000f }     // 830 nm
};

float x1931(float w) {
	int index = w - 360;
	float w2_w = w - (float) w;
	float w1_w = 1.f - w2_w;
	index = max(min(index, 470), 0);
	float retval = xyz1931_1nm[index][0] * w1_w + xyz1931_1nm[index+1][0] * w2_w;
	return retval;
}
float y1931(float w) {
	int index = w - 360;
	float w2_w = w - (float) w;
	float w1_w = 1.f - w2_w;
	index = max(min(index, 470), 0);
	float retval = xyz1931_1nm[index][1] * w1_w + xyz1931_1nm[index+1][1] * w2_w;
	return retval;
}
float z1931(float w) {
	int index = w - 360;
	float w2_w = w - (float) w;
	float w1_w = 1.f - w2_w;
	index = max(min(index, 470), 0);
	float retval = xyz1931_1nm[index][2] * w1_w + xyz1931_1nm[index+1][2] * w2_w;
	return retval;
}

/*float x1931 (float w) {
	return	1.056 * cmf_g(w, 599.8f, 0.0264f, 0.0323f) +
			0.362 * cmf_g(w, 442.f, 0.0624f, 0.0374f) -
			0.065 * cmf_g(w, 501.1f, 0.049f, 0.0382f);
}
float y1931 (float w) {
	return	0.821 * cmf_g(w, 568.8f, 0.0213f, 0.0247f) +
			0.286 * cmf_g(w, 530.9f, 0.0613f, 0.0322f);
}
float z1931 (float w) {
	return	1.217 * cmf_g(w, 437.0f, 0.0845f, 0.0278f) +
			0.681 * cmf_g(w, 459.f, 0.0385f, 0.0725f);
}*/
// CIE 1931 2-degree CMF using multi-lobe piecewise Gaussian
/*float x1931(float w) {
	float t1 = (w-442.0f)*((w<442.0f)?0.0624f:0.0374f);
	float t2 = (w-599.8f)*((w<599.8f)?0.0264f:0.0323f);
	float t3 = (w-501.1f)*((w<501.1f)?0.0490f:0.0382f);
	return 0.362f*expf(-0.5f*t1*t1) + 1.056f*expf(-0.5f*t2*t2)
	- 0.065f*expf(-0.5f*t3*t3);
}

float y1931( float w) {
	float t1 = (w-568.8f)*((w<568.8f)?0.0213f:0.0247f);
	float t2 = (w-530.9f)*((w<530.9f)?0.0613f:0.0322f);
	return 0.821f*expf(-0.5f*t1*t1) + 0.286f*expf(-0.5f*t2*t2);
}

float z1931(float w) {
	float t1 = (w-437.0f)*((w<437.0f)?0.0845f:0.0278f);
	float t2 = (w-459.0f)*((w<459.0f)?0.0385f:0.0725f);
	return 1.217f*expf(-0.5f*t1*t1) + 0.681f*expf(-0.5f*t2*t2);
}
*/
// CIE 1964 10-degree CMF using single-lobe fit
float x1964(float w) {
	float i1 = 0.4f*expf(-1250.f*powf(logf((w+570.f)/1014.0f),2.f));
	float i2 = 1.13f*expf(-234.0f*powf(logf((1338.0f-w)/743.5f),2.f));
	return i1+i2;
}

float y1964(float w) {
	return 1.011f*expf(-0.5f*pow((w-556.1f)/46.14f, 2.f));
}

float z1964(float w) {
	return 2.06f*expf( -32.0f*powf(logf((w-266.0f)/180.4f),2.f));
}

// Returns the emittance of a Planckian black body spectrum at wavelength
// wl and temperature bbTemp
// from "Colour Rendering of Spectra", John Walker, Fourmilab. Public domain code, last updated March 9 2003
/*
float bb_spectrum(float wl, float bbTemp) {
	float wlm = wl * 1e-9;   // Wavelength in meters
	return (3.74183e-16f * pow(wlm, -5.f)) / (expf(1.4388e-2f / (wlm * bbTemp)) - 1.f);
}
*/

int equalize_cfa_fit_with_coeffs(fits *fit, float coeff1, float coeff2, const char *cfa_string) {
	unsigned int row, col, pat_cell;
	/* compute width of the (square) CFA pattern */
	/* added 0.1 in case the result of sqrt is something like 5.999999 and it gets casted to int as 5 */
	unsigned int pat_width = (unsigned int) (sqrt(strlen(cfa_string)) + 0.1);
	if (fit->type == DATA_USHORT) {
		WORD *data = fit->data;
		for (row = 0; row < fit->ry; row ++) {
			for (col = 0; col < fit->rx; col++) {
				pat_cell = (row % pat_width) * pat_width + col % pat_width;
				switch (cfa_string[pat_cell]) {
					case 'R':
						data[col + row * fit->rx] = round_to_WORD(data[col + row * fit->rx] / coeff1);
						break;
					case 'B':
						data[col + row * fit->rx] = round_to_WORD(data[col + row * fit->rx] / coeff2);
						break;
				}
			}
		}
	}
	else if (fit->type == DATA_FLOAT) {
		float *data = fit->fdata;
		for (row = 0; row < fit->ry; row ++) {
			for (col = 0; col < fit->rx; col++) {
				pat_cell = (row % pat_width) * pat_width + col % pat_width;
				switch (cfa_string[pat_cell]) {
					case 'R':
						data[col + row * fit->rx] /= coeff1;
						break;
					case 'B':
						data[col + row * fit->rx] /= coeff2;
						break;
				}
			}
		}
	}
	else return 1;
	return 0;
}

static gpointer extract_channels_ushort(gpointer p) {
	struct extract_channels_data *args = (struct extract_channels_data *) p;
	WORD *buf[3] = { args->fit->pdata[RLAYER], args->fit->pdata[GLAYER],
		args->fit->pdata[BLAYER] };
	size_t n = args->fit->naxes[0] * args->fit->naxes[1];
	struct timeval t_start, t_end;

	if (args->fit->naxes[2] != 3) {
		siril_log_message(
				_("Siril cannot extract layers. Make sure your image is in RGB mode.\n"));
		return GINT_TO_POINTER(1);
	}

	siril_log_color_message(_("%s channel extraction: processing...\n"), "green",
			args->str_type);
	gettimeofday(&t_start, NULL);
	gchar *histstring = NULL;
	cmsHPROFILE cielab_profile = NULL, image_profile = NULL;
	cmsColorSpaceSignature sig;
	cmsUInt32Number trans_type, lab_type;
	gboolean threaded;
	cmsHTRANSFORM transform = NULL;
	cmsUInt32Number datasize;
	cmsUInt32Number bytesperline;
	cmsUInt32Number bytesperplane;
	gchar *desc = siril_color_profile_get_description(args->fit->icc_profile);
	if(args->fit->icc_profile)
		cmsCloseProfile(args->fit->icc_profile);
	/* The extracted channels are considered raw data, and are not color
		* managed. It is up to the user to ensure that future use of them is
		* with similar data and an appropriate color profile is assigned.
		* See also the HSV and CIELAB cases below.*/
	args->fit->icc_profile = NULL;
	color_manage(args->fit, FALSE);

	switch (args->type) {
	case EXTRACT_RGB:
		histstring = g_strdup_printf(_("%s: extract RGB channel"), extractionstring);
		break;
	case EXTRACT_HSL:
		histstring = g_strdup_printf(_("%s: extract HSL channel"), extractionstring);
#ifdef _OPENMP
#pragma omp parallel for num_threads(com.max_thread) schedule(static)
#endif
		for (size_t i = 0; i < n; i++) {
			double h, s, l;
			double r = (double) buf[RLAYER][i] / USHRT_MAX_DOUBLE;
			double g = (double) buf[GLAYER][i] / USHRT_MAX_DOUBLE;
			double b = (double) buf[BLAYER][i] / USHRT_MAX_DOUBLE;
			// RGB to HSL is a coordinate transform and does not require lcms
			rgb_to_hsl(r, g, b, &h, &s, &l);
			buf[RLAYER][i] = round_to_WORD(h * 360.0);
			buf[GLAYER][i] = round_to_WORD(s * USHRT_MAX_DOUBLE);
			buf[BLAYER][i] = round_to_WORD(l * USHRT_MAX_DOUBLE);
		}
		break;
	case EXTRACT_HSV:
		histstring = g_strdup_printf(_("%s: extract HSV channel"), extractionstring);
#ifdef _OPENMP
#pragma omp parallel for num_threads(com.max_thread) schedule(static)
#endif
		for (size_t i = 0; i < n; i++) {
			double h, s, v;
			double r = (double) buf[RLAYER][i] / USHRT_MAX_DOUBLE;
			double g = (double) buf[GLAYER][i] / USHRT_MAX_DOUBLE;
			double b = (double) buf[BLAYER][i] / USHRT_MAX_DOUBLE;
			// RGB to HSV is a coordinate transform and does not require lcms
			rgb_to_hsv(r, g, b, &h, &s, &v);
			buf[RLAYER][i] = round_to_WORD(h * 360.0);
			buf[GLAYER][i] = round_to_WORD(s * USHRT_MAX_DOUBLE);
			buf[BLAYER][i] = round_to_WORD(v * USHRT_MAX_DOUBLE);
		}
		break;
	case EXTRACT_CIELAB:
		histstring = g_strdup_printf(_("%s: extract LAB channel"), extractionstring);
		cielab_profile = cmsCreateLab4Profile(NULL);
		if (args->fit->icc_profile) {
			image_profile = copyICCProfile(args->fit->icc_profile);
		} else {
			siril_log_message(_("Image is not color managed. Assuming sRGB.\n"));
			image_profile = srgb_trc();
		}
		sig = cmsGetColorSpace(image_profile);
		trans_type = get_planar_formatter_type(sig, args->fit->type, FALSE);
		lab_type = TYPE_Lab_16_PLANAR;
		threaded = !get_thread_run();
		// We use sRGB as the fallback for non-color managed images
		transform = cmsCreateTransformTHR((threaded ? com.icc.context_threaded : com.icc.context_single), image_profile, trans_type, cielab_profile, lab_type, INTENT_PERCEPTUAL, com.icc.rendering_flags);
		cmsCloseProfile(cielab_profile);
		cmsCloseProfile(image_profile);
		datasize = sizeof(WORD);
		bytesperline = args->fit->rx * datasize;
		bytesperplane = args->fit->rx * args->fit->ry * datasize;
		cmsDoTransformLineStride(transform, args->fit->data, args->fit->data, args->fit->rx, args->fit->ry, bytesperline, bytesperline, bytesperplane, bytesperplane);
		cmsDeleteTransform(transform);
	}
	gchar *fitfilter = g_strdup(args->fit->filter);
	if (desc) {
		args->fit->history = g_slist_append(args->fit->history, g_strdup_printf(_("Channel extraction from 3-channel image with ICC profile:")));
		args->fit->history = g_slist_append(args->fit->history, g_strdup_printf("%s", desc));
	}
	for (int i = 0; i < 3; i++) {
		if (args->channel[i]) {
			update_filter_information(args->fit, add_filter_str[i], TRUE);
			if (i > 0) {
				GSList *current = args->fit->history;
				while (current->next != NULL && current->next->next != NULL) {
					current = current->next;
				}
				// Check if there is only one element in the list.
				if (current->next == NULL) {
					g_slist_free_full(args->fit->history, g_free);
					args->fit->history = NULL;
				} else {
					// Remove the last element.
					GSList *last = current->next;
					current->next = NULL;
					g_free(last->data);
					g_slist_free_1(last);
				}
			}
			args->fit->history = g_slist_append(args->fit->history, g_strdup_printf("%s %d", histstring, i));
			save1fits16(args->channel[i], args->fit, i);
			update_filter_information(args->fit, fitfilter, FALSE); //reinstate original filter name
		}
	}
	g_free(fitfilter);
	g_free(histstring);
	g_free(desc);
	gettimeofday(&t_end, NULL);
	show_time(t_start, t_end);

	return GINT_TO_POINTER(0);
}

static gpointer extract_channels_float(gpointer p) {
	struct extract_channels_data *args = (struct extract_channels_data *) p;
	float *buf[3] = { args->fit->fpdata[RLAYER], args->fit->fpdata[GLAYER],
		args->fit->fpdata[BLAYER] };
	struct timeval t_start, t_end;
	size_t n = args->fit->naxes[0] * args->fit->naxes[1];

	if (args->fit->naxes[2] != 3) {
		siril_log_message(
				_("Siril cannot extract channels. Make sure your image is in RGB mode.\n"));
		return GINT_TO_POINTER(1);
	}

	siril_log_color_message(_("%s channel extraction: processing...\n"), "green",
			args->str_type);
	gettimeofday(&t_start, NULL);
	gchar *histstring = NULL;
	cmsHPROFILE cielab_profile = NULL, image_profile = NULL;
	cmsColorSpaceSignature sig;
	cmsUInt32Number trans_type, lab_type;
	gboolean threaded;
	cmsHTRANSFORM transform = NULL;
	cmsUInt32Number datasize;
	cmsUInt32Number bytesperline;
	cmsUInt32Number bytesperplane;
	gchar *desc = NULL;
	if(args->fit->icc_profile) {
		desc = siril_color_profile_get_description(args->fit->icc_profile);
		cmsCloseProfile(args->fit->icc_profile);
	}
	/* The extracted channels are considered raw data, and are not color
		* managed. It is up to the user to ensure that future use of them is
		* with similar data and an appropriate color profile is assigned.
		* See also the HSV and CIELAB cases below.*/
	args->fit->icc_profile = NULL;
	color_manage(args->fit, FALSE);

	switch (args->type) {
	case EXTRACT_RGB:
		histstring = g_strdup_printf(_("%s: extract RGB channel"), extractionstring);
		break;
	case EXTRACT_HSL:
		histstring = g_strdup_printf(_("%s: extract HSL channel"), extractionstring);
#ifdef _OPENMP
#pragma omp parallel for num_threads(com.max_thread) schedule(static)
#endif
		for (size_t i = 0; i < n; i++) {
			double h, s, l;
			double r = (double) buf[RLAYER][i];
			double g = (double) buf[GLAYER][i];
			double b = (double) buf[BLAYER][i];
			rgb_to_hsl(r, g, b, &h, &s, &l);
			buf[RLAYER][i] = (float) h;
			buf[GLAYER][i] = (float) s;
			buf[BLAYER][i] = (float) l;
		}
		break;
	case EXTRACT_HSV:
		histstring = g_strdup_printf(_("%s: extract HSV channel"), extractionstring);
#ifdef _OPENMP
#pragma omp parallel for num_threads(com.max_thread) schedule(static)
#endif
		for (size_t i = 0; i < n; i++) {
			double h, s, v;
			double r = (double) buf[RLAYER][i];
			double g = (double) buf[GLAYER][i];
			double b = (double) buf[BLAYER][i];
			rgb_to_hsv(r, g, b, &h, &s, &v);
			buf[RLAYER][i] = (float) h;
			buf[GLAYER][i] = (float) s;
			buf[BLAYER][i] = (float) v;
		}
		break;
	case EXTRACT_CIELAB:
		histstring = g_strdup_printf(_("%s: extract LAB channel"), extractionstring);
		cielab_profile = cmsCreateLab4Profile(NULL);
		if (args->fit->icc_profile) {
			image_profile = copyICCProfile(args->fit->icc_profile);
		} else {
			siril_log_message(_("Image is not color managed. Assuming sRGB.\n"));
			image_profile = srgb_trc();
		}
		sig = cmsGetColorSpace(image_profile);
		trans_type = get_planar_formatter_type(sig, args->fit->type, FALSE);
		lab_type = TYPE_Lab_FLT_PLANAR;
		threaded = !get_thread_run();
		transform = cmsCreateTransformTHR((threaded ? com.icc.context_threaded : com.icc.context_single), image_profile, trans_type, cielab_profile, lab_type, com.pref.icc.processing_intent, com.icc.rendering_flags);
		cmsCloseProfile(cielab_profile);
		cmsCloseProfile(image_profile);
		datasize = sizeof(float);
		bytesperline = args->fit->rx * datasize;
		bytesperplane = args->fit->rx * args->fit->ry * datasize;
		/* Note this output is in CIE La*b* ranges (ie L [0..100] etc, not Siril's
		 * usual [0..1] range.
		 * TODO: convert to Siril ranges?
		 */
		cmsDoTransformLineStride(transform, args->fit->fdata, args->fit->fdata, args->fit->rx, args->fit->ry, bytesperline, bytesperline, bytesperplane, bytesperplane);
		cmsDeleteTransform(transform);
	}
	gchar *fitfilter = g_strdup(args->fit->filter);
	if (desc) {
		args->fit->history = g_slist_append(args->fit->history, g_strdup_printf(_("Channel extraction from 3-channel image with ICC profile:")));
		args->fit->history = g_slist_append(args->fit->history, g_strdup_printf("%s", desc));
	}
	for (int i = 0; i < 3; i++) {
		if (args->channel[i]) {
			update_filter_information(args->fit, add_filter_str[i], TRUE);
			if (i > 0) {
				GSList *current = args->fit->history;
				while (current->next != NULL && current->next->next != NULL) {
					current = current->next;
				}
				// Check if there is only one element in the list.
				if (current->next == NULL) {
					g_slist_free_full(args->fit->history, g_free);
					args->fit->history = NULL;
				} else {
					// Remove the last element.
					GSList *last = current->next;
					current->next = NULL;
					g_free(last->data);
					g_slist_free_1(last);
				}
			}
			args->fit->history = g_slist_append(args->fit->history, g_strdup_printf("%s %d", histstring, i));
			save1fits32(args->channel[i], args->fit, i);
			update_filter_information(args->fit, fitfilter, FALSE); //reinstate original filter name
		}
	}
	g_free(desc);
	g_free(histstring);
	g_free(fitfilter);
	gettimeofday(&t_end, NULL);
	show_time(t_start, t_end);

	return GINT_TO_POINTER(0);
}

// channels extraction computed in-place
gpointer extract_channels(gpointer p) {
	struct extract_channels_data *args = (struct extract_channels_data *)p;
	gpointer retval = GINT_TO_POINTER(1);

	if (args->fit->type == DATA_USHORT)
		retval = extract_channels_ushort(p);
	else if (args->fit->type == DATA_FLOAT)
		retval = extract_channels_float(p);

	clearfits(args->fit);
	free(args->channel[0]);
	free(args->channel[1]);
	free(args->channel[2]);
	free(args);
	siril_add_idle(end_generic, NULL);
	return retval;
}

/****************** Color calibration ************************/

/* This function equalize the background by giving equal value for all layers */
void background_neutralize(fits* fit, rectangle black_selection) {
	int chan;
	size_t i, n = fit->naxes[0] * fit->naxes[1];
	imstats* stats[3];
	double ref = 0;

	assert(fit->naxes[2] == 3);

	for (chan = 0; chan < 3; chan++) {
		stats[chan] = statistics(NULL, -1, fit, chan, &black_selection, STATS_BASIC, MULTI_THREADED);
		if (!stats[chan]) {
			siril_log_message(_("Error: statistics computation failed.\n"));
			return;
		}
		ref += stats[chan]->median;
	}
	ref /= 3.0;

	if (fit->type == DATA_USHORT) {
		for (chan = 0; chan < 3; chan++) {
			double offset = stats[chan]->mean - ref;
			WORD *buf = fit->pdata[chan];
			for (i = 0; i < n; i++) {
				buf[i] = round_to_WORD((double)buf[i] - offset);
			}
			free_stats(stats[chan]);
		}
	}
	else if (fit->type == DATA_FLOAT) {
		for (chan = 0; chan < 3; chan++) {
			float offset = stats[chan]->mean - ref;
			float *buf = fit->fpdata[chan];
			for (i = 0; i < n; i++) {
				buf[i] = buf[i] - offset;
			}
			free_stats(stats[chan]);
		}
	}

	invalidate_stats_from_fit(fit);
	invalidate_gfit_histogram();
}

void get_coeff_for_wb(fits *fit, rectangle white, rectangle black,
		double kw[], double bg[], double norm, double low, double high) {
	int chan, i, j, n;
	double tmp[3] = { 0.0, 0.0, 0.0 };

	assert(fit->naxes[2] == 3);

	if (fit->type == DATA_USHORT) {
		WORD lo = round_to_WORD(low * (norm));
		WORD hi = round_to_WORD(high * (norm));

		for (chan = 0; chan < 3; chan++) {
			n = 0;
			WORD *from = fit->pdata[chan] + (fit->ry - white.y - white.h) * fit->rx
				+ white.x;
			int stridefrom = fit->rx - white.w;

			for (i = 0; i < white.h; i++) {
				for (j = 0; j < white.w; j++) {
					if (*from > lo && *from < hi ) {
						kw[chan] += (double)*from / norm;
						n++;
					}
					from++;
				}
				from += stridefrom;
			}
			if (n > 0)
				kw[chan] /= (double)n;
		}
	}
	else if (fit->type == DATA_FLOAT) {
		for (chan = 0; chan < 3; chan++) {
			n = 0;
			float *from = fit->fpdata[chan] + (fit->ry - white.y - white.h) * fit->rx
				+ white.x;
			int stridefrom = fit->rx - white.w;

			for (i = 0; i < white.h; i++) {
				for (j = 0; j < white.w; j++) {
					double f = (double)*from;
					if (f > low && f < high) {
						kw[chan] += f;
						n++;
					}
					from++;
				}
				from += stridefrom;
			}
			if (n > 0)
				kw[chan] /= (double)n;
		}
	}
	else return;

	siril_log_message(_("Background reference:\n"));
	for (chan = 0; chan < 3; chan++) {
		imstats *stat = statistics(NULL, -1, fit, chan, &black, STATS_BASIC, MULTI_THREADED);
		if (!stat) {
			siril_log_message(_("Error: statistics computation failed.\n"));
			return;
		}
		bg[chan] = stat->median / stat->normValue;
		siril_log_message("B%d: %.5e\n", chan, bg[chan]);
		free_stats(stat);

	}

	siril_log_message(_("White reference:\n"));
	for (chan = 0; chan < 3; chan++) {
		siril_log_message("W%d: %.5e\n", chan, kw[chan]);
		kw[chan] = fabs(kw[chan] - bg[chan]);
	}

	int rc = (kw[0] > kw[1]) ? ((kw[0] > kw[2]) ? 0 : 2) :
		((kw[1] > kw[2]) ? 1 : 2);
	for (chan = 0; chan < 3; chan++) {
		if (chan == rc)
			tmp[chan] = 1.0;
		else
			tmp[chan] = kw[rc] / kw[chan];
	}

	siril_log_message(_("Color calibration factors:\n"));
	for (chan = 0; chan < 3; chan++) {
		kw[chan] = tmp[chan];
		siril_log_message("K%d: %5.3lf\n", chan, kw[chan]);
	}
}

int calibrate(fits *fit, int layer, double kw, double bg, double norm) {
	size_t i, n = fit->naxes[0] * fit->naxes[1];
	if (fit->type == DATA_USHORT) {
		double bgNorm = bg * norm;
		WORD *buf = fit->pdata[layer];
		for (i = 0; i < n; ++i) {
			buf[i] = round_to_WORD((buf[i] - bgNorm) * kw + bgNorm);
		}
	}
	else if (fit->type == DATA_FLOAT) {
		float *buf = fit->fpdata[layer];
		for (i = 0; i < n; ++i) {
			buf[i] = (float)(((double)buf[i] - bg) * kw + bg);
		}
	}
	else return 1;
	return 0;
}

int pos_to_neg(fits *fit) {
	size_t i, n = fit->naxes[0] * fit->naxes[1] * fit->naxes[2];
	if (fit->type == DATA_USHORT) {
		WORD norm = (WORD)get_normalized_value(fit);
#ifdef _OPENMP
#pragma omp parallel for num_threads(com.max_thread)
#endif
		for (i = 0; i < n; i++) {
			fit->data[i] = norm - fit->data[i];
		}
	}
	else if (fit->type == DATA_FLOAT) {
#ifdef _OPENMP
#pragma omp parallel for num_threads(com.max_thread)
#endif
		for (i = 0; i < n; i++) {
			fit->fdata[i] = 1.0f - fit->fdata[i];
		}
	}
	else return 1;

	return 0;
}
